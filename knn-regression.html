<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KNN Regression Web App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin-top: 20px;
      color: #333;
    }
    #controls {
      margin: 20px 0;
      display: flex;
      gap: 20px;
      align-items: center;
    }
    label {
      font-size: 16px;
      color: #444;
    }
    canvas {
      background: #e9e9e9;
      border: 1px solid #bbb;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin-bottom: 20px;
      cursor: crosshair;
    }
    button, input[type="range"] {
      font-size: 16px;
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #aaa;
      background: #fff;
      transition: background 0.2s;
    }
    button:hover {
      background: #f0f0f0;
      cursor: pointer;
    }
    #kValue {
      font-weight: bold;
      color: #0074d9;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <h1>KNN Regression Web App</h1>
  <div id="controls">
    <button id="regenBtn">Generate New Dataset</button>
    <button id="clearBtn">Clear Canvas</button>
    <label for="kSlider">Neighbors (k): <span id="kValue">3</span></label>
    <input type="range" id="kSlider" min="1" max="10" value="3">
  </div>
  <canvas id="knnCanvas" width="800" height="600"></canvas>
  <script>
    // --- Data Generation ---
    const canvas = document.getElementById('knnCanvas');
    const ctx = canvas.getContext('2d');
    const regenBtn = document.getElementById('regenBtn');
    const clearBtn = document.getElementById('clearBtn');
    const kSlider = document.getElementById('kSlider');
    const kValueLabel = document.getElementById('kValue');

    let points = [];
    let k = parseInt(kSlider.value);

    // Generate random dataset
    function generatePoints(num = 30) {
      points = [];
      for (let i = 0; i < num; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const value = Math.random() * 100; // Target value between 0 and 100
        points.push({ x, y, value, isPredicted: false });
      }
      drawCanvas();
    }

    // --- Visualization ---
    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const pt of points) {
        drawPoint(pt);
      }
    }

    // Draw a single point with color gradient and label
    function drawPoint(pt) {
      // Color gradient: blue (low) to red (high)
      const color = valueToColor(pt.value);
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, pt.isPredicted ? 8 : 6, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = pt.isPredicted ? '#222' : '#888';
      ctx.lineWidth = pt.isPredicted ? 2 : 1;
      ctx.stroke();
      // Label
      ctx.font = '14px Arial';
      ctx.fillStyle = pt.isPredicted ? '#222' : '#333';
      ctx.fillText(pt.value.toFixed(1), pt.x + 10, pt.y - 10);
    }

    // Map value (0-100) to color gradient
    function valueToColor(value) {
      // Interpolate between blue (low) and red (high)
      const r = Math.round(255 * (value / 100));
      const g = 0;
      const b = Math.round(255 * (1 - value / 100));
      return `rgb(${r},${g},${b})`;
    }

    // --- KNN Logic ---
    // Euclidean distance
    function distance(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    // Predict value for new point using KNN regression
    function predictValue(x, y, k) {
      if (points.length === 0) return 50; // Default if no points
      // Sort points by distance
      const sorted = points.slice().sort((a, b) => distance({x, y}, a) - distance({x, y}, b));
      const neighbors = sorted.slice(0, k);
      // Mean of neighbors' values
      const mean = neighbors.reduce((sum, pt) => sum + pt.value, 0) / neighbors.length;
      return mean;
    }

    // --- Click Handling ---
    canvas.addEventListener('click', function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // Predict value using KNN
      const predValue = predictValue(x, y, k);
      points.push({ x, y, value: predValue, isPredicted: true });
      drawCanvas();
    });

    // --- User Controls ---
    regenBtn.addEventListener('click', () => {
      generatePoints();
    });

    clearBtn.addEventListener('click', () => {
      points = [];
      drawCanvas();
    });

    kSlider.addEventListener('input', () => {
      k = parseInt(kSlider.value);
      kValueLabel.textContent = k;
    });

    // --- Initial Load ---
    generatePoints();

    // --- Comments ---
    // Data generation: generatePoints() creates random (x, y, value) points.
    // Click handling: canvas click adds a new point and predicts its value using KNN.
    // Distance calculation: distance() computes Euclidean distance.
    // KNN prediction: predictValue() finds k nearest neighbors and averages their values.
    // Visualization: drawPoint() colors and labels each point.
  </script>
</body>
</html>
